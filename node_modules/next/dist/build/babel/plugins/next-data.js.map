{"version":3,"sources":["../../../../build/babel/plugins/next-data.ts"],"names":["types","t","visitor","ImportDeclaration","path","state","source","node","value","createHookSpecifier","get","find","specifier","isImportSpecifier","isIdentifier","imported","name","bindingName","local","binding","scope","getBinding","referencePaths","forEach","refPath","callExpression","parentPath","isCallExpression","args","buildCodeFrameError","arguments","push","objectExpression","properties","objectProperty","identifier","stringLiteral","opts","key"],"mappings":"8DAMe,kBAAU,CACvBA,KAAK,CAAEC,CADgB,CAAV,CAII,CACjB,MAAO,CACLC,OAAO,CAAE,CACPC,iBAAiB,CAACC,IAAD,CAA+CC,KAA/C,CAAsD,CACrE,KAAMC,CAAAA,MAAM,CAAGF,IAAI,CAACG,IAAL,CAAUD,MAAV,CAAiBE,KAAhC,CACA,GAAIF,MAAM,GAAK,WAAf,CAA4B,OAE5B,KAAMG,CAAAA,mBAAmB,CAAGL,IAAI,CAACM,GAAL,CAAS,YAAT,EAAuBC,IAAvB,CAA6BC,SAAD,EAAe,CACrE,MACEA,CAAAA,SAAS,CAACC,iBAAV,IACA,CAACZ,CAAC,CAACa,YAAF,CAAeF,SAAS,CAACL,IAAV,CAAeQ,QAA9B,EACGH,SAAS,CAACL,IAAV,CAAeQ,QAAf,CAAwBC,IAD3B,CAEGJ,SAAS,CAACL,IAAV,CAAeQ,QAAf,CAAwBP,KAF5B,IAEuC,YAJzC,CAMD,CAP2B,CAA5B,CASA,GAAI,CAACC,mBAAL,CAA0B,OAE1B,KAAMQ,CAAAA,WAAW,CAAGR,mBAAmB,CAACF,IAApB,CAAyBW,KAAzB,CAA+BF,IAAnD,CACA,KAAMG,CAAAA,OAAO,CAAGf,IAAI,CAACgB,KAAL,CAAWC,UAAX,CAAsBJ,WAAtB,CAAhB,CAEA,GAAI,CAACE,OAAL,CAAc,CACZ,OACD,CAEDA,OAAO,CAACG,cAAR,CAAuBC,OAAvB,CAAgCC,OAAD,EAAa,CAC1C,GAAIC,CAAAA,cAAc,CAAGD,OAAO,CAACE,UAA7B,CAEA,GAAI,CAACD,cAAc,CAACE,gBAAf,EAAL,CAAwC,OAExC,GAAIC,CAAAA,IAAS,CAAGH,cAAc,CAACf,GAAf,CAAmB,WAAnB,CAAhB,CAEA,GAAI,CAACkB,IAAI,CAAC,CAAD,CAAT,CAAc,CACZ,KAAMH,CAAAA,cAAc,CAACI,mBAAf,CACJ,mDADI,CAAN,CAGD,CAED,GAAI,CAACD,IAAI,CAAC,CAAD,CAAT,CAAc,CACZH,cAAc,CAAClB,IAAf,CAAoBuB,SAApB,CAA8BC,IAA9B,CAAmC9B,CAAC,CAAC+B,gBAAF,CAAmB,EAAnB,CAAnC,EACD,CAEDJ,IAAI,CAAGH,cAAc,CAACf,GAAf,CAAmB,WAAnB,CAAP,CAEAkB,IAAI,CAAC,CAAD,CAAJ,CAAQrB,IAAR,CAAa0B,UAAb,CAAwBF,IAAxB,CACE9B,CAAC,CAACiC,cAAF,CACEjC,CAAC,CAACkC,UAAF,CAAa,KAAb,CADF,CAEElC,CAAC,CAACmC,aAAF,CAAgB/B,KAAK,CAACgC,IAAN,CAAWC,GAA3B,CAFF,CADF,EAMD,CAzBD,EA0BD,CAjDM,CADJ,CAAP,CAqDD","sourcesContent":["import {\n  NodePath,\n  PluginObj,\n  types as BabelTypes,\n} from 'next/dist/compiled/babel/core'\n\nexport default function ({\n  types: t,\n}: {\n  types: typeof BabelTypes\n}): PluginObj<any> {\n  return {\n    visitor: {\n      ImportDeclaration(path: NodePath<BabelTypes.ImportDeclaration>, state) {\n        const source = path.node.source.value\n        if (source !== 'next/data') return\n\n        const createHookSpecifier = path.get('specifiers').find((specifier) => {\n          return (\n            specifier.isImportSpecifier() &&\n            (t.isIdentifier(specifier.node.imported)\n              ? specifier.node.imported.name\n              : specifier.node.imported.value) === 'createHook'\n          )\n        })\n\n        if (!createHookSpecifier) return\n\n        const bindingName = createHookSpecifier.node.local.name\n        const binding = path.scope.getBinding(bindingName)\n\n        if (!binding) {\n          return\n        }\n\n        binding.referencePaths.forEach((refPath) => {\n          let callExpression = refPath.parentPath\n\n          if (!callExpression.isCallExpression()) return\n\n          let args: any = callExpression.get('arguments')\n\n          if (!args[0]) {\n            throw callExpression.buildCodeFrameError(\n              'first argument to createHook should be a function'\n            )\n          }\n\n          if (!args[1]) {\n            callExpression.node.arguments.push(t.objectExpression([]))\n          }\n\n          args = callExpression.get('arguments')\n\n          args[1].node.properties.push(\n            t.objectProperty(\n              t.identifier('key'),\n              t.stringLiteral(state.opts.key)\n            )\n          )\n        })\n      },\n    },\n  }\n}\n"]}
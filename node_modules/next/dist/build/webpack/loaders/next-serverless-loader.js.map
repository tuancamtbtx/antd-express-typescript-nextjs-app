{"version":3,"sources":["../../../../build/webpack/loaders/next-serverless-loader.ts"],"names":["vercelHeader","nextServerlessLoader","distDir","absolutePagePath","page","buildId","canonicalBase","assetPrefix","absoluteAppPath","absoluteDocumentPath","absoluteErrorPath","generateEtags","poweredByHeader","basePath","runtimeConfig","previewProps","loadedEnvFiles","i18n","query","substr","buildManifest","BUILD_MANIFEST","replace","reactLoadableManifest","REACT_LOADABLE_MANIFEST","routesManifest","ROUTES_MANIFEST","escapedBuildId","pageIsDynamicRoute","encodedPreviewProps","JSON","parse","i18nEnabled","defaultRouteRegex","normalizeDynamicRouteParams","envLoading","Buffer","from","toString","runtimeConfigImports","runtimeConfigSetter","dynamicRouteImports","dynamicRouteMatcher","rewriteImports","handleRewrites","handleBasePath","handleLocale","match","API_ROUTE","stringify"],"mappings":"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","sourcesContent":["import devalue from 'next/dist/compiled/devalue'\nimport escapeRegexp from 'next/dist/compiled/escape-string-regexp'\nimport { join } from 'path'\nimport { parse } from 'querystring'\nimport { loader } from 'webpack'\nimport { API_ROUTE } from '../../../lib/constants'\nimport {\n  BUILD_MANIFEST,\n  REACT_LOADABLE_MANIFEST,\n  ROUTES_MANIFEST,\n} from '../../../next-server/lib/constants'\nimport { isDynamicRoute } from '../../../next-server/lib/router/utils'\nimport { __ApiPreviewProps } from '../../../next-server/server/api-utils'\n\nexport type ServerlessLoaderQuery = {\n  page: string\n  distDir: string\n  absolutePagePath: string\n  absoluteAppPath: string\n  absoluteDocumentPath: string\n  absoluteErrorPath: string\n  buildId: string\n  assetPrefix: string\n  generateEtags: string\n  poweredByHeader: string\n  canonicalBase: string\n  basePath: string\n  runtimeConfig: string\n  previewProps: string\n  loadedEnvFiles: string\n  i18n: string\n}\n\nconst vercelHeader = 'x-vercel-id'\n\nconst nextServerlessLoader: loader.Loader = function () {\n  const {\n    distDir,\n    absolutePagePath,\n    page,\n    buildId,\n    canonicalBase,\n    assetPrefix,\n    absoluteAppPath,\n    absoluteDocumentPath,\n    absoluteErrorPath,\n    generateEtags,\n    poweredByHeader,\n    basePath,\n    runtimeConfig,\n    previewProps,\n    loadedEnvFiles,\n    i18n,\n  }: ServerlessLoaderQuery =\n    typeof this.query === 'string' ? parse(this.query.substr(1)) : this.query\n\n  const buildManifest = join(distDir, BUILD_MANIFEST).replace(/\\\\/g, '/')\n  const reactLoadableManifest = join(distDir, REACT_LOADABLE_MANIFEST).replace(\n    /\\\\/g,\n    '/'\n  )\n  const routesManifest = join(distDir, ROUTES_MANIFEST).replace(/\\\\/g, '/')\n\n  const escapedBuildId = escapeRegexp(buildId)\n  const pageIsDynamicRoute = isDynamicRoute(page)\n\n  const encodedPreviewProps = devalue(\n    JSON.parse(previewProps) as __ApiPreviewProps\n  )\n\n  const i18nEnabled = !!i18n\n\n  const defaultRouteRegex = pageIsDynamicRoute\n    ? `\n      const defaultRouteRegex = getRouteRegex(\"${page}\")\n    `\n    : ''\n\n  const normalizeDynamicRouteParams = pageIsDynamicRoute\n    ? `\n      function normalizeDynamicRouteParams(query) {\n        return Object.keys(defaultRouteRegex.groups)\n          .reduce((prev, key) => {\n            let value = query[key]\n\n            ${\n              ''\n              // non-provided optional values should be undefined so normalize\n              // them to undefined\n            }\n            if(\n              defaultRouteRegex.groups[key].optional &&\n              (!value || (\n                Array.isArray(value) &&\n                value.length === 1 &&\n                ${\n                  ''\n                  // fallback optional catch-all SSG pages have\n                  // [[...paramName]] for the root path on Vercel\n                }\n                (value[0] === 'index' || value[0] === \\`[[...\\${key}]]\\`)\n              ))\n            ) {\n              value = undefined\n              delete query[key]\n            }\n            ${\n              ''\n              // query values from the proxy aren't already split into arrays\n              // so make sure to normalize catch-all values\n            }\n            if (\n              value &&\n              typeof value === 'string' &&\n              defaultRouteRegex.groups[key].repeat\n            ) {\n              value = value.split('/')\n            }\n\n            if (value) {\n              prev[key] = value\n            }\n            return prev\n          }, {})\n      }\n    `\n    : ''\n  const envLoading = `\n    const { processEnv } = require('@next/env')\n    processEnv(${Buffer.from(loadedEnvFiles, 'base64').toString()})\n  `\n\n  const runtimeConfigImports = runtimeConfig\n    ? `\n      const { setConfig } = require('next/config')\n    `\n    : ''\n\n  const runtimeConfigSetter = runtimeConfig\n    ? `\n      const runtimeConfig = ${runtimeConfig}\n      setConfig(runtimeConfig)\n    `\n    : 'const runtimeConfig = {}'\n\n  const dynamicRouteImports = pageIsDynamicRoute\n    ? `\n    const { getRouteMatcher } = require('next/dist/next-server/lib/router/utils/route-matcher');\n      const { getRouteRegex } = require('next/dist/next-server/lib/router/utils/route-regex');\n  `\n    : ''\n\n  const dynamicRouteMatcher = pageIsDynamicRoute\n    ? `\n    const dynamicRouteMatcher = getRouteMatcher(getRouteRegex(\"${page}\"))\n  `\n    : ''\n\n  const rewriteImports = `\n    const { rewrites } = require('${routesManifest}')\n    const { pathToRegexp, default: pathMatch } = require('next/dist/next-server/lib/router/utils/path-match')\n  `\n\n  const handleRewrites = `\n    const getCustomRouteMatcher = pathMatch(true)\n    const prepareDestination = require('next/dist/next-server/lib/router/utils/prepare-destination').default\n\n    function handleRewrites(parsedUrl) {\n      for (const rewrite of rewrites) {\n        const matcher = getCustomRouteMatcher(rewrite.source)\n        const params = matcher(parsedUrl.pathname)\n\n        if (params) {\n          const { parsedDestination } = prepareDestination(\n            rewrite.destination,\n            params,\n            parsedUrl.query,\n            true,\n            \"${basePath}\"\n          )\n\n          Object.assign(parsedUrl.query, parsedDestination.query)\n          delete parsedDestination.query\n\n          Object.assign(parsedUrl, parsedDestination)\n\n          if (parsedUrl.pathname === '${page}'){\n            break\n          }\n          ${\n            pageIsDynamicRoute\n              ? `\n            const dynamicParams = dynamicRouteMatcher(parsedUrl.pathname);\\\n            if (dynamicParams) {\n              parsedUrl.query = {\n                ...parsedUrl.query,\n                ...dynamicParams\n              }\n              break\n            }\n          `\n              : ''\n          }\n        }\n      }\n\n      return parsedUrl\n    }\n  `\n\n  const handleBasePath = basePath\n    ? `\n    // always strip the basePath if configured since it is required\n    req.url = req.url.replace(new RegExp('^${basePath}'), '') || '/'\n    parsedUrl.pathname = parsedUrl.pathname.replace(new RegExp('^${basePath}'), '') || '/'\n  `\n    : ''\n\n  const handleLocale = i18nEnabled\n    ? `\n      // get pathname from URL with basePath stripped for locale detection\n      const i18n = ${i18n}\n      const accept = require('@hapi/accept')\n      const { detectLocaleCookie } = require('next/dist/next-server/lib/i18n/detect-locale-cookie')\n      const { normalizeLocalePath } = require('next/dist/next-server/lib/i18n/normalize-locale-path')\n      let detectedLocale = detectLocaleCookie(req, i18n.locales)\n\n      if (!detectedLocale) {\n        detectedLocale = accept.language(\n          req.headers['accept-language'],\n          i18n.locales\n        )\n      }\n\n      const denormalizedPagePath = denormalizePagePath(parsedUrl.pathname || '/')\n      const detectedDefaultLocale = detectedLocale === i18n.defaultLocale\n      const shouldStripDefaultLocale =\n        detectedDefaultLocale &&\n        denormalizedPagePath === \\`/\\${i18n.defaultLocale}\\`\n      const shouldAddLocalePrefix =\n        !detectedDefaultLocale && denormalizedPagePath === '/'\n      detectedLocale = detectedLocale || i18n.defaultLocale\n\n      if (\n        !fromExport &&\n        !nextStartMode &&\n        i18n.localeDetection !== false &&\n        (shouldAddLocalePrefix || shouldStripDefaultLocale)\n      ) {\n        res.setHeader(\n          'Location',\n          formatUrl({\n            // make sure to include any query values when redirecting\n            ...parsedUrl,\n            pathname: shouldStripDefaultLocale ? '/' : \\`/\\${detectedLocale}\\`,\n          })\n        )\n        res.statusCode = 307\n        res.end()\n        return\n      }\n\n      // TODO: domain based locales (domain to locale mapping needs to be provided in next.config.js)\n      const localePathResult = normalizeLocalePath(parsedUrl.pathname, i18n.locales)\n\n      if (localePathResult.detectedLocale) {\n        detectedLocale = localePathResult.detectedLocale\n        req.url = formatUrl({\n          ...parsedUrl,\n          pathname: localePathResult.pathname,\n        })\n        parsedUrl.pathname = localePathResult.pathname\n      }\n\n      detectedLocale = detectedLocale || i18n.defaultLocale\n    `\n    : `\n      const i18n = {}\n      const detectedLocale = undefined\n    `\n\n  if (page.match(API_ROUTE)) {\n    return `\n      import initServer from 'next-plugin-loader?middleware=on-init-server!'\n      import onError from 'next-plugin-loader?middleware=on-error-server!'\n      import 'next/dist/next-server/server/node-polyfill-fetch'\n\n      ${envLoading}\n      ${runtimeConfigImports}\n      ${\n        /*\n          this needs to be called first so its available for any other imports\n        */\n        runtimeConfigSetter\n      }\n      ${dynamicRouteImports}\n      const { parse: parseUrl } = require('url')\n      const { apiResolver } = require('next/dist/next-server/server/api-utils')\n      ${rewriteImports}\n\n      ${dynamicRouteMatcher}\n\n      ${defaultRouteRegex}\n\n      ${normalizeDynamicRouteParams}\n\n      ${handleRewrites}\n\n      export default async (req, res) => {\n        try {\n          await initServer()\n\n          // We need to trust the dynamic route params from the proxy\n          // to ensure we are using the correct values\n          const trustQuery = req.headers['${vercelHeader}']\n          const parsedUrl = handleRewrites(parseUrl(req.url, true))\n\n          ${handleBasePath}\n\n          const params = ${\n            pageIsDynamicRoute\n              ? `\n              normalizeDynamicRouteParams(\n                trustQuery\n                  ? parsedUrl.query\n                  : dynamicRouteMatcher(parsedUrl.pathname)\n              )\n              `\n              : `{}`\n          }\n\n          const resolver = require('${absolutePagePath}')\n          await apiResolver(\n            req,\n            res,\n            Object.assign({}, parsedUrl.query, params ),\n            resolver,\n            ${encodedPreviewProps},\n            true,\n            onError\n          )\n        } catch (err) {\n          console.error(err)\n          await onError(err)\n\n          // TODO: better error for DECODE_FAILED?\n          if (err.code === 'DECODE_FAILED') {\n            res.statusCode = 400\n            res.end('Bad Request')\n          } else {\n            // Throw the error to crash the serverless function\n            throw err\n          }\n        }\n      }\n    `\n  } else {\n    return `\n    import initServer from 'next-plugin-loader?middleware=on-init-server!'\n    import onError from 'next-plugin-loader?middleware=on-error-server!'\n    import 'next/dist/next-server/server/node-polyfill-fetch'\n    const {isResSent} = require('next/dist/next-server/lib/utils');\n\n    ${envLoading}\n    ${runtimeConfigImports}\n    ${\n      // this needs to be called first so its available for any other imports\n      runtimeConfigSetter\n    }\n    const {parse: parseUrl, format: formatUrl} = require('url')\n    const {parse: parseQs} = require('querystring')\n    const { renderToHTML } = require('next/dist/next-server/server/render');\n    const { tryGetPreviewData } = require('next/dist/next-server/server/api-utils');\n    const { denormalizePagePath } = require('next/dist/next-server/server/denormalize-page-path')\n    const { setLazyProp, getCookieParser } = require('next/dist/next-server/server/api-utils')\n    const {sendPayload} = require('next/dist/next-server/server/send-payload');\n    const buildManifest = require('${buildManifest}');\n    const reactLoadableManifest = require('${reactLoadableManifest}');\n    const Document = require('${absoluteDocumentPath}').default;\n    const Error = require('${absoluteErrorPath}').default;\n    const App = require('${absoluteAppPath}').default;\n\n    ${dynamicRouteImports}\n    ${rewriteImports}\n\n    const ComponentInfo = require('${absolutePagePath}')\n\n    const Component = ComponentInfo.default\n    export default Component\n    export const unstable_getStaticParams = ComponentInfo['unstable_getStaticParam' + 's']\n    export const getStaticProps = ComponentInfo['getStaticProp' + 's']\n    export const getStaticPaths = ComponentInfo['getStaticPath' + 's']\n    export const getServerSideProps = ComponentInfo['getServerSideProp' + 's']\n\n    // kept for detecting legacy exports\n    export const unstable_getStaticProps = ComponentInfo['unstable_getStaticProp' + 's']\n    export const unstable_getStaticPaths = ComponentInfo['unstable_getStaticPath' + 's']\n    export const unstable_getServerProps = ComponentInfo['unstable_getServerProp' + 's']\n\n    ${dynamicRouteMatcher}\n    ${defaultRouteRegex}\n    ${normalizeDynamicRouteParams}\n    ${handleRewrites}\n\n    export const config = ComponentInfo['confi' + 'g'] || {}\n    export const _app = App\n    export async function renderReqToHTML(req, res, renderMode, _renderOpts, _params) {\n      const fromExport = renderMode === 'export' || renderMode === true;\n      const nextStartMode = renderMode === 'passthrough'\n\n      setLazyProp({ req }, 'cookies', getCookieParser(req))\n\n      const options = {\n        App,\n        Document,\n        buildManifest,\n        getStaticProps,\n        getServerSideProps,\n        getStaticPaths,\n        reactLoadableManifest,\n        canonicalBase: \"${canonicalBase}\",\n        buildId: \"${buildId}\",\n        assetPrefix: \"${assetPrefix}\",\n        runtimeConfig: runtimeConfig.publicRuntimeConfig || {},\n        previewProps: ${encodedPreviewProps},\n        env: process.env,\n        basePath: \"${basePath}\",\n        ..._renderOpts\n      }\n      let _nextData = false\n      let parsedUrl\n\n      try {\n        // We need to trust the dynamic route params from the proxy\n        // to ensure we are using the correct values\n        const trustQuery = !getStaticProps && req.headers['${vercelHeader}']\n        let parsedUrl = parseUrl(req.url, true)\n        let routeNoAssetPath = parsedUrl.pathname${\n          basePath ? `.replace(new RegExp('^${basePath}'), '') || '/'` : ''\n        }\n        const origQuery = Object.assign({}, parsedUrl.query)\n\n        parsedUrl = handleRewrites(parsedUrl)\n\n        ${handleBasePath}\n\n        if (parsedUrl.pathname.match(/_next\\\\/data/)) {\n          const {\n            default: getrouteNoAssetPath,\n          } = require('next/dist/next-server/lib/router/utils/get-route-from-asset-path');\n          _nextData = true;\n          parsedUrl.pathname = getrouteNoAssetPath(\n            parsedUrl.pathname.replace(\n              new RegExp('/_next/data/${escapedBuildId}/'),\n              '/'\n            ),\n            '.json'\n          );\n          routeNoAssetPath = parsedUrl.pathname\n        }\n\n        ${handleLocale}\n\n        const renderOpts = Object.assign(\n          {\n            Component,\n            pageConfig: config,\n            nextExport: fromExport,\n            isDataReq: _nextData,\n            locale: detectedLocale,\n            locales: i18n.locales,\n            defaultLocale: i18n.defaultLocale,\n          },\n          options,\n        )\n\n        ${\n          page === '/_error'\n            ? `\n          if (!res.statusCode) {\n            res.statusCode = 404\n          }\n        `\n            : ''\n        }\n\n        ${\n          pageIsDynamicRoute\n            ? `\n            const params = (\n              fromExport\n            ) ? {}\n              : normalizeDynamicRouteParams(\n                trustQuery\n                  ? parsedUrl.query\n                  : dynamicRouteMatcher(parsedUrl.pathname)\n              )\n            `\n            : `const params = {};`\n        }\n        ${\n          // Temporary work around: `x-now-route-matches` is a platform header\n          // _only_ set for `Prerender` requests. We should move this logic\n          // into our builder to ensure we're decoupled. However, this entails\n          // removing reliance on `req.url` and using `req.query` instead\n          // (which is needed for \"custom routes\" anyway).\n          pageIsDynamicRoute\n            ? `const nowParams = req.headers && req.headers[\"x-now-route-matches\"]\n              ? getRouteMatcher(\n                  (function() {\n                    const { re, groups } = getRouteRegex(\"${page}\");\n                    return {\n                      re: {\n                        // Simulate a RegExp match from the \\`req.url\\` input\n                        exec: str => {\n                          const obj = parseQs(str);\n                          return Object.keys(obj).reduce(\n                            (prev, key) =>\n                              Object.assign(prev, {\n                                [key]: obj[key]\n                              }),\n                            {}\n                          );\n                        }\n                      },\n                      groups\n                    };\n                  })()\n                )(req.headers[\"x-now-route-matches\"])\n              : null;\n          `\n            : `const nowParams = null;`\n        }\n\n        // make sure to set renderOpts to the correct params e.g. _params\n        // if provided from worker or params if we're parsing them here\n        renderOpts.params = _params || params\n\n        // make sure to normalize req.url on Vercel to strip dynamic params\n        // from the query which are added during routing\n        ${\n          pageIsDynamicRoute\n            ? `\n          if (trustQuery) {\n            const _parsedUrl = parseUrl(req.url, true)\n            delete _parsedUrl.search\n\n            for (const param of Object.keys(defaultRouteRegex.groups)) {\n              delete _parsedUrl.query[param]\n            }\n            req.url = formatUrl(_parsedUrl)\n          }\n        `\n            : ''\n        }\n\n        // normalize request URL/asPath for fallback/revalidate pages since the\n        // proxy sets the request URL to the output's path for fallback pages\n        ${\n          pageIsDynamicRoute\n            ? `\n            if (nowParams) {\n              const _parsedUrl = parseUrl(req.url)\n\n              for (const param of Object.keys(defaultRouteRegex.groups)) {\n                const paramIdx = _parsedUrl.pathname.indexOf(\\`[\\${param}]\\`)\n\n                if (paramIdx > -1) {\n                  _parsedUrl.pathname = _parsedUrl.pathname.substr(0, paramIdx) +\n                    encodeURI(nowParams[param]) +\n                    _parsedUrl.pathname.substr(paramIdx + param.length + 2)\n                }\n              }\n              parsedUrl.pathname = _parsedUrl.pathname\n              req.url = formatUrl(_parsedUrl)\n            }\n          `\n            : ``\n        }\n\n        // make sure to normalize asPath for revalidate and _next/data requests\n        // since the asPath should match what is shown on the client\n        if (\n          !fromExport &&\n          (getStaticProps || getServerSideProps)\n        ) {\n          ${\n            pageIsDynamicRoute\n              ? `\n              // don't include dynamic route params in query while normalizing\n              // asPath\n              if (trustQuery) {\n                delete parsedUrl.search\n\n                for (const param of Object.keys(defaultRouteRegex.groups)) {\n                  delete origQuery[param]\n                }\n              }\n            `\n              : ``\n          }\n\n          parsedUrl.pathname = denormalizePagePath(parsedUrl.pathname)\n          renderOpts.resolvedUrl = formatUrl({\n            ...parsedUrl,\n            query: origQuery\n          })\n\n          // For getServerSideProps we need to ensure we use the original URL\n          // and not the resolved URL to prevent a hydration mismatch on asPath\n          renderOpts.resolvedAsPath = getServerSideProps\n            ? formatUrl({\n              ...parsedUrl,\n              pathname: routeNoAssetPath,\n              query: origQuery,\n            })\n            : renderOpts.resolvedUrl\n        }\n\n        const isFallback = parsedUrl.query.__nextFallback\n\n        const previewData = tryGetPreviewData(req, res, options.previewProps)\n        const isPreviewMode = previewData !== false\n\n        if (process.env.__NEXT_OPTIMIZE_FONTS) {\n          renderOpts.optimizeFonts = true\n          /**\n           * __webpack_require__.__NEXT_FONT_MANIFEST__ is added by\n           * font-stylesheet-gathering-plugin\n           */\n          renderOpts.fontManifest = __webpack_require__.__NEXT_FONT_MANIFEST__;\n          process.env['__NEXT_OPTIMIZE_FONT'+'S'] = true\n        }\n        let result = await renderToHTML(req, res, \"${page}\", Object.assign({}, getStaticProps ? { ...(parsedUrl.query.amp ? { amp: '1' } : {}) } : parsedUrl.query, nowParams ? nowParams : params, _params, isFallback ? { __nextFallback: 'true' } : {}), renderOpts)\n\n        if (!renderMode) {\n          if (_nextData || getStaticProps || getServerSideProps) {\n            sendPayload(req, res, _nextData ? JSON.stringify(renderOpts.pageData) : result, _nextData ? 'json' : 'html', ${\n              generateEtags === 'true' ? true : false\n            }, {\n              private: isPreviewMode,\n              stateful: !!getServerSideProps,\n              revalidate: renderOpts.revalidate,\n            })\n            return null\n          }\n        } else if (isPreviewMode) {\n          res.setHeader(\n            'Cache-Control',\n            'private, no-cache, no-store, max-age=0, must-revalidate'\n          )\n        }\n\n        if (renderMode) return { html: result, renderOpts }\n        return result\n      } catch (err) {\n        if (!parsedUrl) {\n          parsedUrl = parseUrl(req.url, true)\n        }\n\n        if (err.code === 'ENOENT') {\n          res.statusCode = 404\n        } else if (err.code === 'DECODE_FAILED') {\n          // TODO: better error?\n          res.statusCode = 400\n        } else {\n          console.error('Unhandled error during request:', err)\n\n          // Backwards compat (call getInitialProps in custom error):\n          try {\n            await renderToHTML(req, res, \"/_error\", parsedUrl.query, Object.assign({}, options, {\n              getStaticProps: undefined,\n              getStaticPaths: undefined,\n              getServerSideProps: undefined,\n              Component: Error,\n              err: err,\n              // Short-circuit rendering:\n              isDataReq: true\n            }))\n          } catch (underErrorErr) {\n            console.error('Failed call /_error subroutine, continuing to crash function:', underErrorErr)\n          }\n\n          // Throw the error to crash the serverless function\n          if (isResSent(res)) {\n            console.error('!!! WARNING !!!')\n            console.error(\n              'Your function crashed, but closed the response before allowing the function to exit.\\\\n' +\n              'This may cause unexpected behavior for the next request.'\n            )\n            console.error('!!! WARNING !!!')\n          }\n          throw err\n        }\n\n        const result = await renderToHTML(req, res, \"/_error\", parsedUrl.query, Object.assign({}, options, {\n          getStaticProps: undefined,\n          getStaticPaths: undefined,\n          getServerSideProps: undefined,\n          Component: Error,\n          err: res.statusCode === 404 ? undefined : err\n        }))\n        return result\n      }\n    }\n    export async function render (req, res) {\n      try {\n        await initServer()\n        const html = await renderReqToHTML(req, res)\n        if (html) {\n          sendPayload(req, res, html, 'html', {generateEtags: ${JSON.stringify(\n            generateEtags === 'true'\n          )}, poweredByHeader: ${JSON.stringify(poweredByHeader === 'true')}})\n        }\n      } catch(err) {\n        console.error(err)\n        await onError(err)\n        // Throw the error to crash the serverless function\n        throw err\n      }\n    }\n  `\n  }\n}\n\nexport default nextServerlessLoader\n"]}